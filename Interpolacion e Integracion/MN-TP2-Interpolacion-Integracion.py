"""
Sebastian Vaccaro - 2do cuatri 2025
Trabajo Práctico 2: Interpolación e integración - Métodos Numéricos - UNSAM
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

ciclo_x=np.arange(0,250)

ciclo_y=np.array([-0.00431000000000000,-0.0102400000000000,-0.00889000000000000,-0.00494000000000000,-0.00665000000000000,-0.00620000000000000,-0.00773000000000000,-0.0140200000000000,-0.0109600000000000,-0.00171000000000000,0.0229100000000000,0.0210200000000000,0.0327900000000000,0.0195900000000000,0.00216000000000000,0.00216000000000000,-0.000850000000000000,0.00126000000000000,0.00440000000000000,0.000180000000000000,-0.00337000000000000,-0.0769100000000000,-0.142360000000000,0.129470000000000,0.700000000000000,0.231980000000000,0.0554300000000000,-0.00674000000000000,-0.0381800000000000,-0.0467200000000000,-0.0440200000000000,-0.0456900000000000,-0.0372000000000000,-0.0391700000000000,-0.0363000000000000,-0.0280800000000000,-0.0206200000000000,-0.0176100000000000,-0.0143300000000000,-0.0125300000000000,-0.00216000000000000,0.00584000000000000,0.0156300000000000,0.0253400000000000,0.0417800000000000,0.0582200000000000,0.0752900000000000,0.0832000000000000,0.0921800000000000,0.0954200000000000,0.0876000000000000,0.043750000000000,0.00593000000000000,-0.0274000000000000,-0.0490100000000000,-0.0587600000000000,-0.0659000000000000,-0.0611800000000000,-0.0579500000000000,-0.0579500000000000,-0.0529200000000000,-0.0500400000000000,-0.0426800000000000,-0.0449200000000000,-0.0388100000000000,-0.0376500000000000,-0.0367900000000000,-0.0278500000000000,-0.0298300000000000,-0.0276700000000000,-0.0222800000000000,-0.0215600000000000,-0.0172500000000000,-0.0183300000000000,-0.0153600000000000,-0.0128500000000000,-0.00970000000000000,-0.0152700000000000,-0.00629000000000000,-0.0116800000000000,-0.00979000000000000,-0.00467000000000000,-0.00503000000000000,-0.00395000000000000,-0.00548000000000000,-0.00782000000000000,-0.00256000000000000,-0.00305000000000000,-0.00422000000000000,-0.00988000000000000,-0.0104200000000000,-0.00602000000000000,-0.00916000000000000,-0.0127600000000000,-0.00773000000000000,-0.0136600000000000,0.0201300000000000,0.0230000000000000,0.0305500000000000,0.0271300000000000,0.00629000000000000,-0.00252000000000000,0.00139000000000000,-0.00166000000000000,-0.00449000000000000,-0.00822000000000000,-0.00759000000000000,-0.0350400000000000,-0.169360000000000,-0.0174700000000000,0.473130000000000,0.700000000000000,0.0385400000000000,0.00382000000000000,-0.0417800000000000,-0.0436600000000000,-0.0456900000000000,-0.0477100000000000,-0.0388100000000000,-0.0363000000000000,-0.0309100000000000,-0.0224200000000000,-0.0176500000000000,-0.0111900000000000,-0.00782000000000000,0.00162000000000000,0.00252000000000000,0.0132100000000000,0.0225100000000000,0.0330600000000000,0.0501300000000000,0.0637900000000000,0.0817600000000000,0.0965800000000000,0.110240000000000,0.111770000000000,0.0963600000000000,0.0573200000000000,0.0163500000000000,-0.0183300000000000,-0.0469000000000000,-0.0611800000000000,-0.0640600000000000,-0.0668500000000000,-0.0656800000000000,-0.0652300000000000,-0.0629400000000000,-0.0563300000000000,-0.0483400000000000,-0.0476200000000000,-0.0452400000000000,-0.0376500000000000,-0.0363000000000000,-0.0315400000000000,-0.0245700000000000,-0.0212000000000000,-0.0221000000000000,-0.0220100000000000,-0.0181500000000000,-0.0115000000000000,-0.0107800000000000,-0.00979000000000000,-0.00503000000000000,-0.00588000000000000,-0.00827000000000000,-0.00755000000000000,-0.00467000000000000,-0.00544000000000000,-0.000630000000000000,-0.00225000000000000,-0.00135000000000000,0.00449000000000000,0.00606000000000000,0.000310000000000000,-0.00368000000000000,-0.00898000000000000,-0.00872000000000000,-0.0129400000000000,0.0212000000000000,0.0175600000000000,0.0236300000000000,0.0190000000000000,0.00467000000000000,-0.00283000000000000,-0.00975000000000000,-0.00889000000000000,-0.0137900000000000,-0.00773000000000000,-0.0118600000000000,-0.0483400000000000,-0.168550000000000,0.0269500000000000,0.700000000000000,0.401070000000000,0.0429500000000000,-0.0172500000000000,-0.0592100000000000,-0.0608300000000000,-0.0661300000000000,-0.0633900000000000,-0.0579500000000000,-0.0522900000000000,-0.0409700000000000,-0.0332400000000000,-0.0263700000000000,-0.0267700000000000,-0.0245300000000000,-0.0178800000000000,-0.00413000000000000,-0.000360000000000000,0.00413000000000000,0.0168900000000000,0.0329700000000000,0.0533700000000000,0.0672000000000000,0.0839200000000000,0.0898500000000000,0.100940000000000,0.0877800000000000,0.0576800000000000,0.0139300000000000,-0.0152700000000000,-0.0332400000000000,-0.0497700000000000,-0.0526500000000000,-0.0542700000000000,-0.0469000000000000,-0.0460000000000000,-0.0451900000000000,-0.0322500000000000,-0.0344100000000000,-0.0319400000000000,-0.0353100000000000,-0.0317600000000000,-0.0237200000000000,-0.0244400000000000,-0.0207500000000000,
-0.0163100000000000,-0.0106000000000000,-0.0115000000000000,-0.00970000000000000,-0.00916000000000000,-0.00943000000000000,-0.00485000000000000,-0.00719000000000000,-0.00880000000000000,-0.00818000000000000,-0.0111900000000000,-0.0109200000000000,
-0.0109600000000000])

"""
1. Desde el gráfico de la curva que le devuelve el programa, Intente determinar en los 
datos los diferentes ciclos completos y separarlos.
"""
plt.figure(figsize=(10, 4))
plt.plot(ciclo_x, ciclo_y, label="Datos ECG", color="blue")
plt.title("Datos ECG")
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.grid(True)
plt.legend()
plt.show()

"""
2. Hacer el gráfico de al menos uno de los ciclos aislados. En el mismo, marcar los
puntos de los datos usando asteriscos rojos (*).

"""

# Un ciclo completo
plt.figure(figsize=(10, 4))
plt.plot(ciclo_x, ciclo_y, 'r*', label="Puntos de los datos")
plt.title("Puntos de los datos ECG")
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.grid(True)
plt.legend()
plt.show()
"""
3. Hallar un polinomio interpolador por esos puntos y graficarlo en simultáneo con los 
puntos en (*). Al graficar, usar un vector x más fino (agregar nodos intermedios).
"""
# Polinomio de grado 15, con n-1 no funcionaba bien para graficar
coeficientes_polinomio = np.polyfit(ciclo_x, ciclo_y, 15)
# Valores del polinomio en un x más fino
x_fino = np.linspace(min(ciclo_x), max(ciclo_x), len(ciclo_x) + len(ciclo_x)-1)
Y_polinomio = np.polyval(coeficientes_polinomio, x_fino)
# Graficar
plt.figure(figsize=(10, 4))
plt.plot(ciclo_x, ciclo_y, 'r*', markersize=8, label='Datos')
plt.plot(x_fino, Y_polinomio, 'b-', label='Polinomio interpolador')
plt.title("Interpolación polinómica de los datos ECG")
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.grid()
plt.legend()
plt.show()

"""
4. Idem con splines.
"""

Spline = CubicSpline(ciclo_x, ciclo_y)
y_spline = Spline(x_fino)

# Graficar
plt.figure(figsize=(10, 4))
plt.plot(ciclo_x, ciclo_y, 'r*', markersize=8, label='Datos')
plt.plot(x_fino, y_spline, 'g-', label='Spline cúbico')
plt.title("Interpolación con Spline cúbico de los datos ECG")
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.grid()
plt.legend()
plt.show()

"""
5. Calcular la integral para el ciclo completo
"""

x_2 = np.linspace(min(ciclo_x), max(ciclo_x), len(ciclo_x) + (len(ciclo_x) - 1) * 2)   # 2 nodos intermedios
x_5 = np.linspace(min(ciclo_x), max(ciclo_x), len(ciclo_x) + (len(ciclo_x) - 1) * 5)   # 5 nodos intermedios

y_spline2 = Spline(x_2)
integral_TrapeciosS2 = np.trapezoid(y_spline2, x_2)

y_spline5 = Spline(x_5)
integral_TrapeciosS5 = np.trapezoid(y_spline5, x_5)

print(f"Integral con spline (2 nodos intermedios): {integral_TrapeciosS2}")
print(f"Integral con spline (5 nodos intermedios): {integral_TrapeciosS5}")

# 5.2 Método de Trapecios 
integral_Trapecios = np.trapezoid(ciclo_y, ciclo_x)
print(f"5.2 Integral con Trapecios: {integral_Trapecios:.6f}")

# 5.3 Método de Simpson
def simpson(x, y):
    n = len(x) - 1
    h = (x[len(x) - 1] - x[0]) / n
    
    if n % 2 == 0:  # n debe ser PAR para Simpson
        suma_impares = sum(y[i] for i in range(1, n, 2))
        suma_pares = sum(y[i] for i in range(2, n-1, 2))
        integral = (h/3) * (y[0] + y[n] + 4*suma_impares + 2*suma_pares)
    else:
        # Si n es impar, usar trapecio
        print(f"""n es impar ({n}), aplicando método de Trapecios para el último segmento.""")
        integral = simpson(x[:len(x) - 1], y[:len(y) - 1]) + (h/2) * (y[len(y) - 2] + y[len(y) - 1])
    
    return integral

integral_simpson = simpson(ciclo_x, ciclo_y)
print(f"5.3 Integral con Simpson: {integral_simpson:.6f}")

# Verificar si es normal (entre 0.20 y 0.50)
print(f"\n¿ECG normal? (0.20 ≤ integral ≤ 0.50): {0.20 <= integral_Trapecios <= 0.50}")
